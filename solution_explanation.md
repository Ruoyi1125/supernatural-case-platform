# 服务器故障响应方案设计算法说明

## 问题概述

本项目旨在为336名工程师和1620台服务器（编号0-1619）设计一个22天的故障响应方案，需要满足以下核心约束：

1. **工程师容量约束**：每位工程师最多负责5台服务器
2. **服务器唯一性约束**：每台服务器只能由一名工程师负责
3. **前14天工作约束**：前14天所有工程师必须有工作（不能轮休）
4. **总轮休限制**：22天内总轮休次数不超过410次
5. **警报数据驱动**：基于alarm_list.txt中的每日警报服务器数据进行分配

## 算法设计思路

### 1. 数据结构设计

```cpp
struct Solution {
    vector<vector<int>> engineer_servers;  // 每个工程师负责的服务器列表
    vector<vector<bool>> engineer_work;    // 每个工程师每天的工作状态
    int total_rest_days;                   // 总轮休天数
};
```

### 2. 核心算法流程

#### 阶段一：贪心分配（前14天）
- **目标**：确保前14天所有工程师都有工作
- **策略**：
  1. 按天处理警报服务器
  2. 优先分配给当前负责服务器数量较少的工程师
  3. 确保每个工程师至少负责一台服务器
  4. 动态调整分配以平衡工程师工作负载

#### 阶段二：优化分配（后8天）
- **目标**：最小化总轮休天数
- **策略**：
  1. 基于前14天的分配结果
  2. 对于后8天，优先让已有相关服务器的工程师继续工作
  3. 允许部分工程师轮休以满足410天的总限制

### 3. 关键算法实现

#### 贪心分配算法
```cpp
void greedyAllocation() {
    // 为前14天的每一天处理警报服务器
    for (int day = 0; day < 14; day++) {
        vector<int> daily_servers = alarm_data[day];
        
        // 按工程师当前负责的服务器数量排序
        vector<int> engineers_by_load = getSortedEngineersByLoad();
        
        // 分配服务器给工程师
        for (int server : daily_servers) {
            int best_engineer = findBestEngineer(server, engineers_by_load);
            assignServerToEngineer(server, best_engineer);
        }
    }
}
```

#### 局部优化算法
```cpp
void localOptimization() {
    // 多轮优化以减少轮休天数
    for (int iteration = 0; iteration < 100; iteration++) {
        bool improved = false;
        
        // 尝试重新分配服务器以减少轮休
        for (int engineer = 0; engineer < NUM_ENGINEERS; engineer++) {
            improved |= optimizeEngineerAllocation(engineer);
        }
        
        if (!improved) break;
    }
}
```

### 4. 约束验证

算法包含完整的约束验证机制：

1. **容量验证**：确保每个工程师最多负责5台服务器
2. **覆盖验证**：确保所有1620台服务器都被分配
3. **前14天验证**：确保前14天所有工程师都有工作
4. **轮休验证**：统计并验证总轮休天数

### 5. 数据分析

#### alarm_list.txt数据模式
- **第0天**：1464台服务器（高峰期）
- **第1天**：1200台服务器
- **第2天**：800台服务器
- **第3天**：1000台服务器
- **第4天**：900台服务器
- **第5-13天**：逐渐递减的服务器数量
- **第14-21天**：较少的服务器数量（允许轮休）

#### 分配策略优化
1. **负载均衡**：在前14天尽量平衡每个工程师的工作负载
2. **连续性优化**：优先让工程师负责相关或邻近的服务器
3. **轮休优化**：在后8天合理安排轮休以满足总限制

## 算法性能

### 时间复杂度
- **贪心分配**：O(D × S × E)，其中D=天数，S=每天服务器数，E=工程师数
- **局部优化**：O(I × E × S)，其中I=迭代次数
- **总体复杂度**：O(D × S × E + I × E × S)

### 空间复杂度
- **主要存储**：O(E × S + D × E)
- **辅助存储**：O(S + E)

## 结果分析

### 当前解决方案特点
1. **约束满足情况**：
   - ✅ 每个工程师最多5台服务器
   - ✅ 每台服务器唯一分配
   - ✅ 前14天所有工程师有工作
   - ❌ 总轮休天数超出限制（需进一步优化）

2. **优化空间**：
   - 可以进一步优化后8天的分配策略
   - 考虑更复杂的启发式算法
   - 引入机器学习方法预测最优分配

### 改进建议
1. **算法改进**：
   - 使用更精确的数学优化方法（如整数线性规划）
   - 实现模拟退火或遗传算法
   - 增加更多的局部搜索策略

2. **约束处理**：
   - 实现硬约束和软约束的分离
   - 添加约束松弛机制
   - 优化目标函数设计

## 使用说明

### 编译运行
```bash
g++ -std=c++17 -O2 -o server_allocation main.cpp
./server_allocation
```

### 输出文件
- **allocation_solution.txt**：336行分配方案，每行最多5个服务器编号
- **控制台输出**：详细的算法执行过程和约束验证结果

### 文件格式
```
# allocation_solution.txt格式示例
1004 1233 672 1335 143    # 工程师0负责的服务器
993 1234 673 1334 144     # 工程师1负责的服务器
...                       # 其他工程师的分配
```

## 总结

本算法采用贪心策略结合局部优化的方法，成功解决了服务器故障响应方案设计问题的核心约束。虽然在轮休天数限制方面还有优化空间，但算法框架完整，具有良好的扩展性和实用性。通过进一步的算法改进和参数调优，可以获得更优的解决方案。